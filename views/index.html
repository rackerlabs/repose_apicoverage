<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>API Coverage Demo</title>
    <link href="http://getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet"/>
    <style>
      svg {
        width: 100%;
      }
      #contents {
        position: relative;;
        top: -19em;
      }
    </style>
  </head>
  <body>
    <div id="cluster_content">
    </div>
    <p id="contents">
      <button type="button" id="execute" data-loading-text="Run Tests" class="btn btn-primary">
        Render Results
      </button>
    </p>
    <div id="total_path">
      <table class="table">
        <tr>
          <th>Data</th>
          <th>Total Paths</th>
          <th>Covered Paths</th>
          <th>Percent covered</th>
          <th>Details</th>
        </tr>
        <tr>
          <td>Failed</td>
          <td id="total_failed_paths"></td>
          <td id="covered_failed_paths"></td>
          <td id="percent_failed_paths"></td>
          <td><button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#failedModal">View failed details</button></td>
        </tr>
        <tr>
          <td>Passed</td>
          <td id="total_passed_paths"></td>
          <td id="covered_passed_paths"></td>
          <td id="percent_passed_paths"></td>
          <td><button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#passedModal">View passed details</button></td>
        </tr>
      </table>
    </div>
    <div class="modal fade" id="failedModal" tabindex="-1" role="dialog" aria-labelledby="failedModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="failedModalLabel">Failed Details</h4>
          </div>
          <div class="modal-body" id="failed-details">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal fade" id="passedModal" tabindex="-1" role="dialog" aria-labelledby="passedModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            <h4 class="modal-title" id="passedModalLabel">Passed Details</h4>
          </div>
          <div class="modal-body" id="passed-details">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
    <script src="http://mdaines.github.io/viz.js/viz.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="http://getbootstrap.com/dist/js/bootstrap.min.js"></script>
    <script>
      var nodeData = [];
      var nodeList = [];
      var failStates = [];
      var tempNodeCount = [];
      var visitedPaths = [];
      var happyPaths = [];
      var failedPaths = [];
      var visitedHappyPaths = [];
      var visitedFailedPaths = [];
      //two calls -- /api/roles and /api/roles/:role
      $.when( $.ajax( "api/roles" ) ).then(function( data, textStatus, jqXHR ) {
        //result is role list of json
        var that = this;
        that.roleData = data;
        for(var i = 0; i < that.roleData.length; i ++ ){
          var specificRoleData = that.roleData[i]
          $.when($.ajax("api/roles/file?file=" + data[i].file)).then(function(innerData, innerStatus, innerXHR){
            var jsGraphviz = document.createElement('script');
            jsGraphviz.type = "text/vnd.graphviz";
            jsGraphviz.id = specificRoleData.role;
            var first = document.getElementsByTagName('script')[0];
            first.parentNode.insertBefore(jsGraphviz, first);
            jsGraphviz.innerHTML = innerData;
            $('#cluster_content').append(render(specificRoleData.role, "svg")); //this renders a role          
            nodeData = nodeData.concat(innerData.match(/(\w+->\w+)/g));
            failStates = failStates.concat(uniqBy(innerData.match(/(w\w+[M|U])/g), JSON.stringify));
          });
        }
      });

      if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
          return str.length > 0 && this.substring( this.length - str.length, this.length ) === str;
        }
      };

      if ( typeof String.prototype.startsWith != 'function' ) {
        String.prototype.startsWith = function( str ) {
          return str.length > 0 && this.substring( 0, str.length ) === str;
        }
      };

      if ( typeof String.prototype.lastCharacter != 'function' ) {
        String.prototype.lastCharacter = function() {
          return this.substring( this.length - 1, this.length );
        }
      };

      function inspect(s) {
        return "<pre>" + s.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;") + "</pre>"
      }

      function src(id) {
        return document.getElementById(id).innerHTML;
      }

      function render(id, format) {
        var result;
        try {
          return  Viz(src(id), format);
        } catch(e) {
          return inspect(e.toString());
        }
      }

      function uniqBy(a, key) {
        var seen = {};
        return a.filter(function(item) {
            var k = key(item);
            return seen.hasOwnProperty(k) ? false : (seen[k] = true);
        })
      }

      function getColor(id) {
        if(id.endsWith("U") || id.endsWith("M") || id.endsWith("C") || id.endsWith("R")){
          return 'red'
        } else {
          return 'lightblue'
        }
      }

      function addToPath(id, path) {
        if(id.endsWith("U") || id.endsWith("M") || id.endsWith("C") || id.endsWith("R")){
          failedPaths.push(path)
        } else {
          happyPaths.push(path)
        }
      }

      function addToVisitedPath(id, path) {
        if(id.endsWith("U") || id.endsWith("M") || id.endsWith("C") || id.endsWith("R")){
          visitedFailedPaths.push(path)
        } else {
          visitedHappyPaths.push(path)
        }
      }

      function traverse(id, path) {
        console.log("path", path)
        //start with S0
        var current = nodeList.filter(function(t){ return t.graphId === id})[0];
        //get all  paths
        var textList = nodeData.filter(function(t){ return t.startsWith(id + "->")});
        console.log(textList)
        if(textList.length === 0 ){
          addToPath(id, path)
        } else {
          for(var i = 0; i < textList.length; i ++){
            //get specific path
            var text = textList[i];
            //console.log(text)
            //get child nodes
            var childNodeList = nodeList.filter(function(t){ return t.graphId === textList[i].split("->")[1]});
            for(var j = 0; j < childNodeList.length; j ++ ){
              var childNode = childNodeList[j];
              //console.log(childNode);
              if(current.graphId === childNode.graphId) {
                //end node
                addToPath(id, path + "->" + childNode.dotId)
              } else {
                traverse(childNode.graphId, path + "->" + childNode.dotId)
              }
            }
          }          
        }
      }



      function traverseVisited(id, path) {
        console.log("path", path)
        //start with S0
        var current = nodeList.filter(function(t){ return t.graphId === id})[0];
        //get all  paths
        var textList = nodeData.filter(function(t){ return t.startsWith(id + "->")});
        console.log(textList)
        if(textList.length === 0 && current.count > 0 ){
          addToVisitedPath(id, path)
        } else {
          for(var i = 0; i < textList.length; i ++){
            //get specific path
            var text = textList[i];
            //console.log(text)
            //get child nodes
            var childNodeList = nodeList.filter(function(t){ return t.graphId === textList[i].split("->")[1]});
            for(var j = 0; j < childNodeList.length; j ++ ){
              var childNode = childNodeList[j];
              console.log(childNode.graphId, current.graphId, current.graphId === childNode.graphId, current.graphId == childNode.graphId);

              if(current.graphId === childNode.graphId && childNode.count > 0) {
                //end node

                addToVisitedPath(id, path + "->" + childNode.dotId)
              } else if (childNode.count > 0) {
                traverseVisited(childNode.graphId, path + "->" + childNode.dotId)
              }
            }
          }          
        }
      }

      function colorGraph(id) {
        //get id
        var current = nodeList.filter(function(t){ return t.graphId === id})[0];
        var ellipse = current.graph.next();
        if(ellipse.length > 0){
          ellipse.attr('fill', getColor(current.graphId));
          //get all nodes that start with id
          var textList = nodeData.filter(function(t){ return t.startsWith(id + "->")});
          for(var i = 0; i < textList.length; i ++){
            //get child nodes
            var childNodeList = nodeList.filter(function(t){ return t.graphId === textList[i].split("->")[1]});
            for(var j = 0; j < childNodeList.length; j ++ ){
              var childNode = childNodeList[j];
              var edge = $("#cluster_content title").filter(function(t) { return ($(this).text() === textList[i]) });
              var path = edge.next();
              if(childNode.count > 0){
                if(current.graphId === childNode.graphId){
                  path.attr('stroke', getColor(childNode.graphId));
                  path.attr('stroke-width', childNode.count);
                  var title = path.next().next();
                  var titleText = title.text();  
                  if(visitedPaths.indexOf(textList[i]) == -1){
                    title.text(titleText + " - " + childNode.count);
                    visitedPaths.push(textList[i]);
                  }
                } else if(current.count > childNode.count){
                  path.attr('stroke', getColor(childNode.graphId));
                  path.attr('stroke-width', childNode.count);
                  var title = path.next().next();
                  var titleText = title.text();  
                  if(visitedPaths.indexOf(textList[i]) == -1){
                    title.text(titleText + " - " + childNode.count);
                    visitedPaths.push(textList[i]);
                  }
                  colorGraph(childNode.graphId);
                } else if (current.count <= childNode.count) {
                  //get temp 
                  var tempList = tempNodeCount.filter(function(t) { return t.graphId === childNode });
                  if(tempList.length === 0) {
                    //no temp list exists.  Update!
                    var temp = {};
                    jQuery.extend(temp,childNode);
                    temp.count = temp.count - current.count;
                    tempList.push(temp);
                    path.attr('stroke', getColor(childNode.graphId));
                    path.attr('stroke-width', current.count);
                    var title = path.next().next();
                    var titleText = title.text();  
                    if(visitedPaths.indexOf(textList[i]) == -1){
                      title.text(titleText + " - " + current.count);
                      visitedPaths.push(textList[i]);
                    }
                    colorGraph(childNode.graphId);
                  } else {
                    var temp = tempList[0];
                    temp.count = temp.count - current.count;
                    path.attr('stroke', getColor(childNode.graphId));
                    path.attr('stroke-width', current.count);
                    var title = path.next().next();
                    var titleText = title.text();  
                    if(visitedPaths.indexOf(textList[i]) == -1){
                      title.text(titleText + " - " + current.count);
                      visitedPaths.push(textList[i]);
                    }
                    colorGraph(childNode.graphId);
                  }
                } 
              }
            }
          }
        }
      }

      var rgb = [96,96,255]
      $(function(){
        $('#execute').on('click',function(){
          $.when( $.ajax( "api/results" ) ).then(function( data, textStatus, jqXHR ) {
            var result = data;
            var color = 0
            var count = 0

            //get fail states from output.dot...this is what will match the other states to make sure that we get back a valid entry
            //var failStates = result.value.filter(function() { return $(this)})
            for(node in result.value){
              //THE SCOPE should match the role_####
              //scope = role = id
              var realNode = node.match(/name=\"(\w+)\"/)[1];
              var scope = node.match(/scope=\"(\w+)_.*\"/)[1];

              //get the nodes that match the actual names
              //instead of just title do #role title
              var nodeInGraph = $("#cluster_content title").filter(function() { return ($(this).text() === realNode) });
              if(nodeInGraph.length == 0 ){
                //this is a fail state.  it's usually a <previous pass state before _>(U|M|H|C)F_<end role>
                var tokens = realNode.split('_');
                for(var i = 0; i < failStates.length; i ++){
                  if(tokens[0].endsWith(failStates[i].lastCharacter() + 'F')){
                    //dotId and graphId are different here
                    nodeInGraph = $("#cluster_content title").filter(function() { return ($(this).text() === failStates[i]) });
                    nodeList.push({graphId: failStates[i], dotId: realNode, count : result.value[node].Count, graph: nodeInGraph});
                  }
                }
              } else {
                //this should now be dotId, graphId, count 
                nodeList.push({dotId: realNode, graphId: realNode, count : result.value[node].Count, graph: nodeInGraph})
              }
            }
            /**
            iterate through node list
            1. start at S0
            2. get all 4 nodes
            2. find all paths that end with this node
            3. for each path, get the previous node and find out how many counts are there.  add that count to the stroke
            */
            colorGraph("S0");
            traverse("S0", "S0");
            traverseVisited("S0", "S0");
            $('#total_passed_paths').html(uniqBy(happyPaths, JSON.stringify).length);
            $('#covered_passed_paths').html(uniqBy(visitedHappyPaths, JSON.stringify).length);
            $('#percent_passed_paths').html(uniqBy(visitedHappyPaths, JSON.stringify).length / uniqBy(happyPaths, JSON.stringify).length * 100);
            $('#total_failed_paths').html(uniqBy(failedPaths, JSON.stringify).length);
            $('#covered_failed_paths').html(uniqBy(visitedFailedPaths, JSON.stringify).length);
            $('#percent_failed_paths').html(uniqBy(visitedFailedPaths, JSON.stringify).length / uniqBy(failedPaths, JSON.stringify).length * 100);
            $('#failed-details').html(uniqBy(visitedFailedPaths, JSON.stringify).join('<br/>'));
            $('#passed-details').html(uniqBy(visitedHappyPaths, JSON.stringify).join('<br/>'));
          });
          $('#execute').html('Refresh')
        });
      });
    </script>
  </body>
</html>